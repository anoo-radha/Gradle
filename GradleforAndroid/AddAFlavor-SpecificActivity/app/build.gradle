/*

Now let's add an entirely new activity to one flavor. We'll make an app where
both flavors present a "Tell Joke" button. In the paid flavor that button will
launch a new activity that displays a joke, while the free flavor will display
a toast telling the user to upgrade to the paid version.

Exercises:

1. Import the project into Android Studio.
2. Build the project and deploy it onto a device (or emulator).
3. Declare free and paid flavors, and replicate MainActivity across the flavors.
4. Build and deploy both flavors of your app to confirm that everything still
   works.
4. Add an activity to the paid flavor that tells a joke. Remember the manifest!
5. Change the action of the button such that it launches your new activity.
6. Build and deploy both flavors of your app to confirm that the new activity
   is only in the paid flavor.

*/

apply plugin: 'com.android.application'

android {
    compileSdkVersion 24
    buildToolsVersion "24.0.1"

    defaultConfig {
        applicationId "com.udacity.gradle.flavorspecificactivity"
        minSdkVersion 15
        targetSdkVersion 24
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    productFlavors{
        free {
            applicationId "com.udacity.gradle.flavorspecificactivity.free"
        }
        paid {
            applicationId "com.udacity.gradle.flavorspecificactivity.paid"
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:24.1.1'
}

/*

the Android Gradle plugin makes is very simple for us  to
declare product flavors for our app. Android plugin creates source sets for each of our flavors, automatically.
These source sets work just like source sets for regular Java projects. In
additional to having unique source directories for each source set, we can
also assign them unique dependencies. Essentially, this means we can declare
dependencies independently for each product flavor.

Let's continue to use the free vs paid app flavor example, since it's a
pretty common one. It's is probably likely that we would enable ads in our
free version, but not in the paid version of the app. Utilizing Google's ad
services requires us to depend on the ad services library. However, we don't
want to unnecessarily bloat the paid version of our app by including a
library that won't be used. To solve this problem, we can simply declare this
dependency only for the 'free' flavor. We can do this because, since flavors
are just extra source sets, Gradle has created flavor-specific configurations
that we can assign our dependencies too. I think you can guess what these
configurations are prefixed with.

*/

// dependencies {
//     compile fileTree(dir: 'libs', include: ['*.jar'])
//     compile 'com.android.support:appcompat-v7:24.1.1'
//     freeCompile 'com.google.android.gms:play-services-ads:9.4.0'
// }

/*

Since the ad services library will be a compile-time dependency, we add it to
the 'freeCompile' configuration. We could just as well add flavor-specific
test or runtime dependencies as well. Also, we don't have to repeat our
default dependencies. Dependencies that are not assigned to a flavor-specific
configuration are available in all product flavors.

*/
