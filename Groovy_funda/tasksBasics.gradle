/*
Just like a closure can have a delegate object, the entire build script delegates
to a projectobject. All the keywords in the Gradle DSL are properties of, or
methods on,the project object.

For instance, the project object has a method called `task` for declaring
tasks. It accepts a name of a new task and a configuration closure, which
we'll talk about shortly.

*/

project.task("myTask1")

/*

Since the entire build script delegates to `project`, we can leave that
off.

*/

task("myTask2")

/*

Because Groovy syntax is awesome, we can leave off the parentheses.

*/

task "myTask3"

/*

This next part is a little tricky. Gradle uses an advanced Groovy feature to
change how the syntax of task declaration is compiled. The upshot is that we
can knock off the quotes.

For more info, check out Mark's post on Stack Overflow here:

http://stackoverflow.com/questions/27584463/understing-the-groovy-syntax-in-a-gradle-task-definition

*/

task myTask4

/*

Here we have the standard way to declare a task. Since the task is a Groovy
object we can set its properties and access its methods. Let's add a
description and a group to this task.

*/

myTask4.description = "This is what's shown in the task list"
myTask4.group = "This is the heading for this task in the task list,"

/*

The most important property of a task is the list of actions it will perform.
Instead of setting the `actions` property of our task, we can add a closure to
the end of the list using the `doLast` method.

*/

myTask4.doLast {println "Do this last"}

/*

We can also add actions to the start of the list using `doFirst`.

*/

myTask4.doFirst {println "Do this first"}

/*

We can also add actions using the `leftShift` operator.

*/

myTask4.leftShift {println "Do this even more last"}
myTask4 << {println "Do this last of all"}

/*

We can also declare a task and give it an action in a single stroke. This is a
very common pattern.

*/

task myTask5 << {
    println "Here's how to declare a task and give it an action in one stroke"
}

/*

Instead of declaring a task and then setting its properties afterwards, we can
also give the task a configuration closure when it's declared.

*/

task myTask6 {
    description "Here's a task with a configuration block"
    group "Some group"
    doLast {
        println "Here's the action"
    }
}

/*

There are two important things to know to understand this configuration
closure. The first is that when this closure is evaluated, its delegate is the
task object. That means when you're assigning to `group`, you're really
assigning to `task.group`. The second thing is that the properties of the task
object are decorated with setters with the same names. That's how we can omit
equals signs when we're to assigning to properties. We're really calling a
setter and leaving off the parentheses.

The only gotcha is that you must include the equals sign or parentheses when
assigning a collection to a property.

*/

task myTask7 {
    description("Description") // Function call works
    //description "Description" // This is identical to the line above
    group = "Some group" // Assignment also works
    doLast { // We can also omit the parentheses, because Groovy syntax
        println "Here's the action"
    }
}

/*

One more important piece of syntax. There are some task properties you can set
using the following syntax:

*/

task myTask8(description: "Another description") << {
    println "Doing something"
}

/*

The choice to set properties here or in the configuration block or even later
on in the script is mostly up to readability, except for one case. If you are
giving your task a type, that needs to be declared here, and not in a
configuration block.

*/

/*

Now that we can declare tasks, it's time to think about the relationships
between tasks. For example, in a Java build, we can't JAR up our library
before compiling our sources. We model these relationships by task
dependencies and ordering.

We'll discuss three ways to configure the relationships between tasks:
`dependsOn`, `finalizedBy`, and `mustRunAfter`.

Task A `dependsOn` task B if task A can't do its work without task B having
done its work. To take a familiar example, when you're getting up in the
morning, you can't put on your shoes without putting on your socks first.
Let's declare and configure some tasks to represent this process.

*/

task putOnSocks {
    doLast {
        println "Putting on Socks."
    }
}

task putOnShoes {
    dependsOn "putOnSocks"
    doLast {
        println "Putting on Shoes."
    }
}

/*

One thing to note is that if you run `gradle tasks`, you won't see
`putOnSocks`. That's because Gradle assumes that `putOnSocks` exists only to
help `putOnShoes` do its job. You can still see the `putOnSocks` task by
running `gradle tasks --all`.

Task A is `finalizedBy` task B if every time task A runs, task B should be run
afterwards. To continue our example, every time you eat breakfast, you must
brush your teeth afterwards. Let's create those tasks, and declare the
relationship between them.

*/

task eatBreakfast {
    finalizedBy "brushYourTeeth"
    doLast{
        println "Om nom nom breakfast!"
    }
}

task brushYourTeeth {
    doLast {
        println "Brushie Brushie Brushie."
    }
}

/*

The use case for `mustRunAfter` is slightly less obvious. Say we have a long
running process that's unlikely to fail, like deploying some artifact to a
continuous integration server, and we also have a short running task that is
likely to fail, like running unit tests. Those two tasks don't have any
dependency relationship, but if we're running both, we would really like the
unit tests to run before the integration tests.

To continue our morning routine example, let's consider showering and putting
on a fragrance like perfume or cologne. Putting on a fragrance doesn't require
showering, and showering doesn't require putting on a fragrance, but if we're
going to both take a shower and also put on a fragrance, we should take the
shower first. Let's create those tasks and the relationship between them.

*/

task takeShower {
    doLast {
        println "Taking a shower."
    }
}

task putOnFragrance {
    shouldRunAfter "takeShower"
    doLast{
        println "Smellin' fresh!"
    }
}

/*

Now if we run `gradle putOnFragrance takeShower`, we see that we do the tasks
in the proper order.

Let's check out a few other things we can do with task dependencies. We can
depend on multiple tasks:

*/

task getReady {
    // Remember that when assigning a collection to a property, we need the
    // equals sign
    dependsOn = ["takeShower", "eatBreakfast", "putOnShoes"]
}

/*

Oops, we put on our shoes before taking a shower! Let's put in another
`mustRunAfter` relationship.

*/

putOnShoes.mustRunAfter takeShower

/*

One more advanced thing we can do is look at all the tasks in the project and
decide which ones we want to depend on. Let's make a task called `getEquipped`
that depends on every task that starts with "putOn".

*/

task getEquipped {
    dependsOn tasks.matching{ task -> task.name.startsWith("putOn")}
    doLast {
        println "All geared up!"
    }
}

/*
For more information about tasks, check out this section of the Gradle
user guide for more info:

    https://docs.gradle.org/current/userguide/more_about_tasks.html

*/

