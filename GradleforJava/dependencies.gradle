/*
we can define dependencies on
artifacts contained in those repositories. Dependencies that are resolved from
repositories are referred to as 'external module dependencies'. Dependencies
are assigned to 'configurations'. We'll talk more about configuration in
detail later but for now you can simply consider them to be groups of related
dependencies.

*/

dependencies {
    compile 'com.google.guava:guava:18.0'
}

/*

For the examples here we'll be adding dependencies to the
'compile' configuration which is added by the Java plugin. Dependencies are
configured in the `dependencies { }` script block. The syntax used is the name
of the configuration we want to add the dependency to, followed by a
dependency notation. External module dependencies are identified by their
group, name and version.

A Groovy map syntax can also be used to identify dependencies.

*/

dependencies {
    compile group: 'com.google.guava', name: 'guava', version: '18.0'
}

/*

In some cases we simply have files that we want to add as dependencies. File
dependencies are declared very similarly to managed dependencies, however,
instead of a dependency notation, we simply use a `FileCollection` or
`FileTree`. In this example, we are simply adding two JAR files as
dependencies by creating a `FileCollection`.

*/

dependencies {
    compile files('libs/foo.jar', 'libs/bar.jar')
}

/*

We can also use a `FileTree`, which allows us to do things like specify
filters. This is useful for including a number of files within a directory.

*/

dependencies {
    compile fileTree(dir: 'libs', include: '*.jar')
}

/*

Different dependencies may be needed at different times in the build process.
Logically related dependencies are grouped into configurations. So far we've
been adding dependencies to the 'compile' configuration, but the Java plugin
creates other configurations as well, such as runtime, testCompile and
testRuntime. The Java plugin ensures that the specified dependencies are on
the classpath when the corresponding tasks are run.

Dependencies can be added to any of these configurations by simply using the
name of the configuration followed by a dependency notation.

*/

apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    compile 'commons-logging:commons-logging:1.1.3'
    testCompile 'junit:junit:4.12'
}

/*

Here we have added a dependency to the 'testCompile' configuration. This
dependency will only be available from our test code.

Configurations can extend other configurations. For example, the 'testCompile'
configuration extends from the 'compile' configuration, which means that
'compile' dependencies are automatically included in 'testCompile'. We can
verify this by generating a dependency report.

    $ gradle dependencies

Here we can see that the 'compile' configuration contains only the 'commons-
logging' dependency, however, 'testCompile' contains both 'junit' and
'commons-logging'.

If you have a more advanced build, with dependencies that don't fit into a
configuration defined by the Java plugin, you can create a custom
configuration. Just add the name of your configuration to the `configurations`
script block. We can then assign dependencies to this configuration.

*/

configurations {
    custom
}

dependencies {
    custom 'com.google.guava:guava:18.0'
}

/*

We can run a dependency report to see that we have a new project configuration
named 'custom' with the 'guava' dependency.

    $ gradle dependencies

Configurations are really just fancy file collections and can be used anywhere
a file collection can be used, such as in Copy tasks. This is useful if we
want to download some dependencies from a remote repository and bundle them in
our project somehow.

*/

task copyDependencies(type: Copy) {
    from configurations.custom
    into 'build/libs'
}

// JAVA UNIT TESTING
/*

Gradle provides built-in support for testing your applications. Core support
is provided for JUnit and TestNG testing frameworks. To get started running
unit tests all you need to do is place your tests in the 'src/test/java'
directory when using the Java plugin. You can, of course, change the location
of your test code by configuring the 'test' source set. Gradle will
automatically compile and run any appropriately annotated tests that are found
in the 'test' source set. The only things we have to manually configure are
our test dependencies. In this example we're using JUnit as our testing
framework so we add a 'junit' dependency to the 'testCompile' configuration.

Running our tests is easy, just run the 'test' task.

    $ gradle test

You'll notice Gradle performs all the required steps to run our tests. It
first compiles our production code, followed by our test code, and then runs
our tests.

Gradle also provides detailed reports on our test execution. These reports are
placed in the 'build/reports' directory. Let's take a look at one of these
reports. On Mac you can use:

    $ open build/reports/tests/index.html


In case of a test failure, our build will fail with a message indicating which
test or tests failed. We can then take a look at the detailed report to try
and troubleshoot while our test is failing. In this case you can see the
failed test is identified and a stacktrace is provided for debugging purposes.

*/

apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.12'
}
